Index: src/pid_controller.c
===================================================================
RCS file: /home/ck/group/software/JAviatorQuadrotor/Gumstix/src/pid_controller.c,v
retrieving revision 1.10
retrieving revision 1.11
diff -u -r1.10 -r1.11
--- src/pid_controller.c	7 Nov 2008 11:26:58 -0000	1.10
+++ src/pid_controller.c	7 Nov 2008 11:59:11 -0000	1.11
@@ -1,4 +1,4 @@
-/* $Id: pid_controller.c,v 1.10 2008/11/07 11:26:58 diercan Exp $ */
+/* $Id: pid_controller.c,v 1.11 2008/11/07 11:59:11 diercan Exp $ */
 
 /** \file pid_controller.c
 *
@@ -36,8 +36,8 @@
 #include "filters/butter.h"
 #include "filters/kalman.h"
 
-#define INTEGRAL_LIMIT   1000 //!< Limit used for integral anti-windup (mrad*ms)
-#define ERROR_LIMIT      6284 //!< Limit for yaw winding (2*pi)
+#define INTEGRAL_LIMIT   1 //!< Limit used for integral anti-windup (rad*s)
+#define ERROR_LIMIT      6.284 //!< Limit for yaw winding (2*pi)
 
 //TODO: this to constants should be moved to a different file
 #define GRAVITY			 9.81  	//!< The value of gravitational acceleration [m/s^2]
@@ -47,15 +47,15 @@
 
 /** \brief State of a controller for 1 degree of freedom. */
 struct controller_state {
-	double dtime;        			//!< Control period (ms)
-	double Kp;           			//!< Gain for tracking error (PWM/mrad)
-	double Ki;           			//!< Gain for integral of tracking error (PWM/(mrad*ms))
-	double Kd;           			//!< Gain for derivative of tracking error (PWM/(mrad/ms))
+	double dtime;        			//!< Control period (s)
+	double Kp;           			//!< Gain for tracking error (PWM/rad)
+	double Ki;           			//!< Gain for integral of tracking error (PWM/(rad*s))
+	double Kd;           			//!< Gain for derivative of tracking error (PWM/(rad/s))
 	double Kdd;          			//!< Gain for double derivative (second derivative) of tracking error
-	double integral;     			//!< Running integral of the tracking error (mrad*ms)
-	double iMax;         			//!< Maximum integral value (mrad*ms)
-	double iMin;         			//!< Minimum integral value (mrad*ms)
-	double last_desired; 			//!< Stores command to use for finite differencing (mrad)
+	double integral;     			//!< Running integral of the tracking error (rad*s)
+	double iMax;         			//!< Maximum integral value (rad*s)
+	double iMin;         			//!< Minimum integral value (rad*s)
+	double last_desired; 			//!< Stores command to use for finite differencing (rad)
 	//TODO: this two filters should be moved somewhere else they should not be mixed with PID controller
 	struct kalman_filter kalman_filter;	//!< Stores the state of the Kalman filter used only for altitude control
 	struct butter_filter butter_filter;	//!< Stores the state of the butter filter used only for altitude control
@@ -69,10 +69,10 @@
  * commands to calculate the error, integral of the error, and derivatives of the error.  Integral
  * antiwindup is included as well.
  * \param controller          *controller, a pointer to control parameters and internal state
- * \param current_angle        double, the current value of the angle (mrad)
- * \param desired_angle        double, the desired (commanded) value of the angle (mrad)
- * \param angular_velocity     double, the current value of the angular velocity (mrad/s)
- * \param angular_acceleration double, the current value of the angular acceleration (mrad/s^2
+ * \param current_angle        double, the current value of the angle (rad)
+ * \param desired_angle        double, the desired (commanded) value of the angle (rad)
+ * \param angular_velocity     double, the current value of the angular velocity (rad/s)
+ * \param angular_acceleration double, the current value of the angular acceleration (rad/s^2
  *
  * \return Requested control effort for the degree of freedom.
  */
@@ -87,7 +87,7 @@
     //TODO: from control point of view this is strange we can live it like this but we have to be carefull not to have
     //positive reaction, normaly the error is computed the other way around
     double error                    =  desired_angle - current_angle; // Angle error from desired value
-    double desired_angular_velocity = (desired_angle - state->last_desired) / (0.001 * state->dtime); // Finite differenced angular velocity
+    double desired_angular_velocity = (desired_angle - state->last_desired) / state->dtime; // Finite differenced angular velocity
     double pTerm, iTerm, dTerm, ddTerm, offset; // Individual contributions of each metric of control error
 
     state->last_desired = desired_angle; // Store for next iteration
@@ -122,17 +122,17 @@
     	//also the z acceleration has to be offseted with + Gravity 
     	//(when the JAviator stays still acceleration is -9.81m/s^2)
     	//the result is multiply with 1000 to return to mm/s^2
-    	angular_acceleration = apply_butter_filter(&state->butter_filter, angular_acceleration + GRAVITY) * 1000.0;
+    	angular_acceleration = apply_butter_filter(&state->butter_filter, angular_acceleration + GRAVITY);
     	
     	//apply kalman filter to find z velocity again the filter works with
     	// m and s, thus the result has to be scalled with 1000 to return to mm/s
-    	angular_velocity 	 = apply_kalman_filter(&state->kalman_filter, current_angle/1000.0, 
-    								angular_acceleration/1000.0, state->dtime / 1000.0) * 1000.0;    	
+    	angular_velocity 	 = apply_kalman_filter(&state->kalman_filter, current_angle, 
+    								angular_acceleration, state->dtime);    	
 
 		// for altitude controller we need an offset since otherwise the intergal part will get to big right at the begining
 		// and might cause us troubles, it has to be multiplied with 1000 to be in sync with the rest of the calculations
 		// this has to be set to a negative value since the error is computed wrong
-		offset = (TAKE_OFF_THRUST * 1000.0);
+		offset = 0;//no need for gravity compensation this is done after the functiuon is called (TAKE_OFF_THRUST);
 
 		//TODO: Harald, I am not sure what this does...
 		set_z_values((int)angular_velocity, (int)angular_acceleration);
@@ -143,7 +143,7 @@
     }
     
     // Compute integral of error
-    state->integral += error * state->dtime / 1000.0;
+    state->integral += error * state->dtime;
 
     // Saturate the integral (anti-windup)
     if( state->integral > state->iMax )
@@ -248,7 +248,7 @@
 	}
 
 	memset( state, 0, sizeof( struct controller_state ) );
-    state->dtime = period;
+    state->dtime = period/1000.0;	//controller used period in seconds
     state->iMax  = INTEGRAL_LIMIT;
     state->iMin  = -INTEGRAL_LIMIT;
 	state->last_desired = 0;
